// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_conf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_conf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_conf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_conf_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_conf_2eproto;
namespace config {
class Bootstrap;
struct BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Local;
struct LocalDefaultTypeInternal;
extern LocalDefaultTypeInternal _Local_default_instance_;
class Local_GRPC;
struct Local_GRPCDefaultTypeInternal;
extern Local_GRPCDefaultTypeInternal _Local_GRPC_default_instance_;
class PlatInfo;
struct PlatInfoDefaultTypeInternal;
extern PlatInfoDefaultTypeInternal _PlatInfo_default_instance_;
class PlatInfo_InternalArray;
struct PlatInfo_InternalArrayDefaultTypeInternal;
extern PlatInfo_InternalArrayDefaultTypeInternal _PlatInfo_InternalArray_default_instance_;
class Serial;
struct SerialDefaultTypeInternal;
extern SerialDefaultTypeInternal _Serial_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_GRPC;
struct Server_GRPCDefaultTypeInternal;
extern Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
}  // namespace config
PROTOBUF_NAMESPACE_OPEN
template<> ::config::Bootstrap* Arena::CreateMaybeMessage<::config::Bootstrap>(Arena*);
template<> ::config::Local* Arena::CreateMaybeMessage<::config::Local>(Arena*);
template<> ::config::Local_GRPC* Arena::CreateMaybeMessage<::config::Local_GRPC>(Arena*);
template<> ::config::PlatInfo* Arena::CreateMaybeMessage<::config::PlatInfo>(Arena*);
template<> ::config::PlatInfo_InternalArray* Arena::CreateMaybeMessage<::config::PlatInfo_InternalArray>(Arena*);
template<> ::config::Serial* Arena::CreateMaybeMessage<::config::Serial>(Arena*);
template<> ::config::Server* Arena::CreateMaybeMessage<::config::Server>(Arena*);
template<> ::config::Server_GRPC* Arena::CreateMaybeMessage<::config::Server_GRPC>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace config {

// ===================================================================

class Bootstrap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Bootstrap) */ {
 public:
  inline Bootstrap() : Bootstrap(nullptr) {}
  ~Bootstrap() override;
  explicit PROTOBUF_CONSTEXPR Bootstrap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bootstrap(const Bootstrap& from);
  Bootstrap(Bootstrap&& from) noexcept
    : Bootstrap() {
    *this = ::std::move(from);
  }

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bootstrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
               &_Bootstrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Bootstrap& a, Bootstrap& b) {
    a.Swap(&b);
  }
  inline void Swap(Bootstrap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bootstrap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bootstrap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bootstrap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bootstrap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Bootstrap& from) {
    Bootstrap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bootstrap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Bootstrap";
  }
  protected:
  explicit Bootstrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 4,
    kServerFieldNumber = 1,
    kLocalFieldNumber = 2,
    kSerialFieldNumber = 3,
  };
  // string uuid = 4 [json_name = "uuid"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .config.Server server = 1 [json_name = "server"];
  bool has_server() const;
  private:
  bool _internal_has_server() const;
  public:
  void clear_server();
  const ::config::Server& server() const;
  PROTOBUF_NODISCARD ::config::Server* release_server();
  ::config::Server* mutable_server();
  void set_allocated_server(::config::Server* server);
  private:
  const ::config::Server& _internal_server() const;
  ::config::Server* _internal_mutable_server();
  public:
  void unsafe_arena_set_allocated_server(
      ::config::Server* server);
  ::config::Server* unsafe_arena_release_server();

  // .config.Local local = 2 [json_name = "local"];
  bool has_local() const;
  private:
  bool _internal_has_local() const;
  public:
  void clear_local();
  const ::config::Local& local() const;
  PROTOBUF_NODISCARD ::config::Local* release_local();
  ::config::Local* mutable_local();
  void set_allocated_local(::config::Local* local);
  private:
  const ::config::Local& _internal_local() const;
  ::config::Local* _internal_mutable_local();
  public:
  void unsafe_arena_set_allocated_local(
      ::config::Local* local);
  ::config::Local* unsafe_arena_release_local();

  // .config.Serial serial = 3 [json_name = "serial"];
  bool has_serial() const;
  private:
  bool _internal_has_serial() const;
  public:
  void clear_serial();
  const ::config::Serial& serial() const;
  PROTOBUF_NODISCARD ::config::Serial* release_serial();
  ::config::Serial* mutable_serial();
  void set_allocated_serial(::config::Serial* serial);
  private:
  const ::config::Serial& _internal_serial() const;
  ::config::Serial* _internal_mutable_serial();
  public:
  void unsafe_arena_set_allocated_serial(
      ::config::Serial* serial);
  ::config::Serial* unsafe_arena_release_serial();

  // @@protoc_insertion_point(class_scope:config.Bootstrap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::config::Server* server_;
    ::config::Local* local_;
    ::config::Serial* serial_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_GRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server.GRPC) */ {
 public:
  inline Server_GRPC() : Server_GRPC(nullptr) {}
  ~Server_GRPC() override;
  explicit PROTOBUF_CONSTEXPR Server_GRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server_GRPC(const Server_GRPC& from);
  Server_GRPC(Server_GRPC&& from) noexcept
    : Server_GRPC() {
    *this = ::std::move(from);
  }

  inline Server_GRPC& operator=(const Server_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_GRPC& operator=(Server_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_GRPC* internal_default_instance() {
    return reinterpret_cast<const Server_GRPC*>(
               &_Server_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Server_GRPC& a, Server_GRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Server_GRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_GRPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_GRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server_GRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server_GRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Server_GRPC& from) {
    Server_GRPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server_GRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server.GRPC";
  }
  protected:
  explicit Server_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1 [json_name = "network"];
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string addr = 2 [json_name = "addr"];
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // .google.protobuf.Duration timeout = 3 [json_name = "timeout"];
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:config.Server.GRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  explicit PROTOBUF_CONSTEXPR Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Server(const Server& from);
  Server(Server&& from) noexcept
    : Server() {
    *this = ::std::move(from);
  }

  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
               &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Server& a, Server& b) {
    a.Swap(&b);
  }
  inline void Swap(Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Server& from) {
    Server::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Server";
  }
  protected:
  explicit Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Server_GRPC GRPC;

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcFieldNumber = 1,
  };
  // .config.Server.GRPC grpc = 1 [json_name = "grpc"];
  bool has_grpc() const;
  private:
  bool _internal_has_grpc() const;
  public:
  void clear_grpc();
  const ::config::Server_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::config::Server_GRPC* release_grpc();
  ::config::Server_GRPC* mutable_grpc();
  void set_allocated_grpc(::config::Server_GRPC* grpc);
  private:
  const ::config::Server_GRPC& _internal_grpc() const;
  ::config::Server_GRPC* _internal_mutable_grpc();
  public:
  void unsafe_arena_set_allocated_grpc(
      ::config::Server_GRPC* grpc);
  ::config::Server_GRPC* unsafe_arena_release_grpc();

  // @@protoc_insertion_point(class_scope:config.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::config::Server_GRPC* grpc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Local_GRPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Local.GRPC) */ {
 public:
  inline Local_GRPC() : Local_GRPC(nullptr) {}
  ~Local_GRPC() override;
  explicit PROTOBUF_CONSTEXPR Local_GRPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Local_GRPC(const Local_GRPC& from);
  Local_GRPC(Local_GRPC&& from) noexcept
    : Local_GRPC() {
    *this = ::std::move(from);
  }

  inline Local_GRPC& operator=(const Local_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Local_GRPC& operator=(Local_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Local_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Local_GRPC* internal_default_instance() {
    return reinterpret_cast<const Local_GRPC*>(
               &_Local_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Local_GRPC& a, Local_GRPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Local_GRPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Local_GRPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Local_GRPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Local_GRPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Local_GRPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Local_GRPC& from) {
    Local_GRPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Local_GRPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Local.GRPC";
  }
  protected:
  explicit Local_GRPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1 [json_name = "network"];
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string addr = 2 [json_name = "addr"];
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // .google.protobuf.Duration timeout = 3 [json_name = "timeout"];
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // @@protoc_insertion_point(class_scope:config.Local.GRPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Local final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Local) */ {
 public:
  inline Local() : Local(nullptr) {}
  ~Local() override;
  explicit PROTOBUF_CONSTEXPR Local(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Local(const Local& from);
  Local(Local&& from) noexcept
    : Local() {
    *this = ::std::move(from);
  }

  inline Local& operator=(const Local& from) {
    CopyFrom(from);
    return *this;
  }
  inline Local& operator=(Local&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Local& default_instance() {
    return *internal_default_instance();
  }
  static inline const Local* internal_default_instance() {
    return reinterpret_cast<const Local*>(
               &_Local_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Local& a, Local& b) {
    a.Swap(&b);
  }
  inline void Swap(Local* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Local* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Local* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Local>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Local& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Local& from) {
    Local::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Local* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Local";
  }
  protected:
  explicit Local(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Local_GRPC GRPC;

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcFieldNumber = 1,
  };
  // .config.Local.GRPC grpc = 1 [json_name = "grpc"];
  bool has_grpc() const;
  private:
  bool _internal_has_grpc() const;
  public:
  void clear_grpc();
  const ::config::Local_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::config::Local_GRPC* release_grpc();
  ::config::Local_GRPC* mutable_grpc();
  void set_allocated_grpc(::config::Local_GRPC* grpc);
  private:
  const ::config::Local_GRPC& _internal_grpc() const;
  ::config::Local_GRPC* _internal_mutable_grpc();
  public:
  void unsafe_arena_set_allocated_grpc(
      ::config::Local_GRPC* grpc);
  ::config::Local_GRPC* unsafe_arena_release_grpc();

  // @@protoc_insertion_point(class_scope:config.Local)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::config::Local_GRPC* grpc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Serial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.Serial) */ {
 public:
  inline Serial() : Serial(nullptr) {}
  ~Serial() override;
  explicit PROTOBUF_CONSTEXPR Serial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Serial(const Serial& from);
  Serial(Serial&& from) noexcept
    : Serial() {
    *this = ::std::move(from);
  }

  inline Serial& operator=(const Serial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Serial& operator=(Serial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Serial& default_instance() {
    return *internal_default_instance();
  }
  static inline const Serial* internal_default_instance() {
    return reinterpret_cast<const Serial*>(
               &_Serial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Serial& a, Serial& b) {
    a.Swap(&b);
  }
  inline void Swap(Serial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Serial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Serial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Serial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Serial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Serial& from) {
    Serial::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Serial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.Serial";
  }
  protected:
  explicit Serial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialPortFieldNumber = 1,
    kBaudRateFieldNumber = 2,
    kDataBitsFieldNumber = 3,
    kStopBitsFieldNumber = 4,
    kParityFieldNumber = 5,
    kFlowControlFieldNumber = 6,
    kClocalFieldNumber = 7,
  };
  // string serial_port = 1 [json_name = "serialPort"];
  void clear_serial_port();
  const std::string& serial_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_port();
  PROTOBUF_NODISCARD std::string* release_serial_port();
  void set_allocated_serial_port(std::string* serial_port);
  private:
  const std::string& _internal_serial_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_port(const std::string& value);
  std::string* _internal_mutable_serial_port();
  public:

  // int32 baud_rate = 2 [json_name = "baudRate"];
  void clear_baud_rate();
  int32_t baud_rate() const;
  void set_baud_rate(int32_t value);
  private:
  int32_t _internal_baud_rate() const;
  void _internal_set_baud_rate(int32_t value);
  public:

  // int32 data_bits = 3 [json_name = "dataBits"];
  void clear_data_bits();
  int32_t data_bits() const;
  void set_data_bits(int32_t value);
  private:
  int32_t _internal_data_bits() const;
  void _internal_set_data_bits(int32_t value);
  public:

  // int32 stop_bits = 4 [json_name = "stopBits"];
  void clear_stop_bits();
  int32_t stop_bits() const;
  void set_stop_bits(int32_t value);
  private:
  int32_t _internal_stop_bits() const;
  void _internal_set_stop_bits(int32_t value);
  public:

  // int32 parity = 5 [json_name = "parity"];
  void clear_parity();
  int32_t parity() const;
  void set_parity(int32_t value);
  private:
  int32_t _internal_parity() const;
  void _internal_set_parity(int32_t value);
  public:

  // bool flow_control = 6 [json_name = "flowControl"];
  void clear_flow_control();
  bool flow_control() const;
  void set_flow_control(bool value);
  private:
  bool _internal_flow_control() const;
  void _internal_set_flow_control(bool value);
  public:

  // bool clocal = 7 [json_name = "clocal"];
  void clear_clocal();
  bool clocal() const;
  void set_clocal(bool value);
  private:
  bool _internal_clocal() const;
  void _internal_set_clocal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:config.Serial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_port_;
    int32_t baud_rate_;
    int32_t data_bits_;
    int32_t stop_bits_;
    int32_t parity_;
    bool flow_control_;
    bool clocal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class PlatInfo_InternalArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.PlatInfo.InternalArray) */ {
 public:
  inline PlatInfo_InternalArray() : PlatInfo_InternalArray(nullptr) {}
  ~PlatInfo_InternalArray() override;
  explicit PROTOBUF_CONSTEXPR PlatInfo_InternalArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlatInfo_InternalArray(const PlatInfo_InternalArray& from);
  PlatInfo_InternalArray(PlatInfo_InternalArray&& from) noexcept
    : PlatInfo_InternalArray() {
    *this = ::std::move(from);
  }

  inline PlatInfo_InternalArray& operator=(const PlatInfo_InternalArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatInfo_InternalArray& operator=(PlatInfo_InternalArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatInfo_InternalArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatInfo_InternalArray* internal_default_instance() {
    return reinterpret_cast<const PlatInfo_InternalArray*>(
               &_PlatInfo_InternalArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlatInfo_InternalArray& a, PlatInfo_InternalArray& b) {
    a.Swap(&b);
  }
  inline void Swap(PlatInfo_InternalArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatInfo_InternalArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatInfo_InternalArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlatInfo_InternalArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlatInfo_InternalArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlatInfo_InternalArray& from) {
    PlatInfo_InternalArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlatInfo_InternalArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.PlatInfo.InternalArray";
  }
  protected:
  explicit PlatInfo_InternalArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // repeated double items = 2 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  double _internal_items(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_items() const;
  void _internal_add_items(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_items();
  public:
  double items(int index) const;
  void set_items(int index, double value);
  void add_items(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_items();

  // int64 index = 1 [json_name = "index"];
  void clear_index();
  int64_t index() const;
  void set_index(int64_t value);
  private:
  int64_t _internal_index() const;
  void _internal_set_index(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:config.PlatInfo.InternalArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > items_;
    int64_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class PlatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:config.PlatInfo) */ {
 public:
  inline PlatInfo() : PlatInfo(nullptr) {}
  ~PlatInfo() override;
  explicit PROTOBUF_CONSTEXPR PlatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlatInfo(const PlatInfo& from);
  PlatInfo(PlatInfo&& from) noexcept
    : PlatInfo() {
    *this = ::std::move(from);
  }

  inline PlatInfo& operator=(const PlatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlatInfo& operator=(PlatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlatInfo* internal_default_instance() {
    return reinterpret_cast<const PlatInfo*>(
               &_PlatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlatInfo& a, PlatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlatInfo& from) {
    PlatInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "config.PlatInfo";
  }
  protected:
  explicit PlatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlatInfo_InternalArray InternalArray;

  // accessors -------------------------------------------------------

  enum : int {
    kAncherFieldNumber = 2,
    kPlateFieldNumber = 3,
    kLtmpFieldNumber = 1,
  };
  // repeated .config.PlatInfo.InternalArray ancher = 2 [json_name = "ancher"];
  int ancher_size() const;
  private:
  int _internal_ancher_size() const;
  public:
  void clear_ancher();
  ::config::PlatInfo_InternalArray* mutable_ancher(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >*
      mutable_ancher();
  private:
  const ::config::PlatInfo_InternalArray& _internal_ancher(int index) const;
  ::config::PlatInfo_InternalArray* _internal_add_ancher();
  public:
  const ::config::PlatInfo_InternalArray& ancher(int index) const;
  ::config::PlatInfo_InternalArray* add_ancher();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >&
      ancher() const;

  // repeated .config.PlatInfo.InternalArray plate = 3 [json_name = "plate"];
  int plate_size() const;
  private:
  int _internal_plate_size() const;
  public:
  void clear_plate();
  ::config::PlatInfo_InternalArray* mutable_plate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >*
      mutable_plate();
  private:
  const ::config::PlatInfo_InternalArray& _internal_plate(int index) const;
  ::config::PlatInfo_InternalArray* _internal_add_plate();
  public:
  const ::config::PlatInfo_InternalArray& plate(int index) const;
  ::config::PlatInfo_InternalArray* add_plate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >&
      plate() const;

  // int32 ltmp = 1 [json_name = "ltmp"];
  void clear_ltmp();
  int32_t ltmp() const;
  void set_ltmp(int32_t value);
  private:
  int32_t _internal_ltmp() const;
  void _internal_set_ltmp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:config.PlatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray > ancher_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray > plate_;
    int32_t ltmp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Bootstrap

// .config.Server server = 1 [json_name = "server"];
inline bool Bootstrap::_internal_has_server() const {
  return this != internal_default_instance() && _impl_.server_ != nullptr;
}
inline bool Bootstrap::has_server() const {
  return _internal_has_server();
}
inline void Bootstrap::clear_server() {
  if (GetArenaForAllocation() == nullptr && _impl_.server_ != nullptr) {
    delete _impl_.server_;
  }
  _impl_.server_ = nullptr;
}
inline const ::config::Server& Bootstrap::_internal_server() const {
  const ::config::Server* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server&>(
      ::config::_Server_default_instance_);
}
inline const ::config::Server& Bootstrap::server() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.server)
  return _internal_server();
}
inline void Bootstrap::unsafe_arena_set_allocated_server(
    ::config::Server* server) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = server;
  if (server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.server)
}
inline ::config::Server* Bootstrap::release_server() {
  
  ::config::Server* temp = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server* Bootstrap::unsafe_arena_release_server() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.server)
  
  ::config::Server* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::config::Server* Bootstrap::_internal_mutable_server() {
  
  if (_impl_.server_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server>(GetArenaForAllocation());
    _impl_.server_ = p;
  }
  return _impl_.server_;
}
inline ::config::Server* Bootstrap::mutable_server() {
  ::config::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.server)
  return _msg;
}
inline void Bootstrap::set_allocated_server(::config::Server* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_;
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server);
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_ = server;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.server)
}

// .config.Local local = 2 [json_name = "local"];
inline bool Bootstrap::_internal_has_local() const {
  return this != internal_default_instance() && _impl_.local_ != nullptr;
}
inline bool Bootstrap::has_local() const {
  return _internal_has_local();
}
inline void Bootstrap::clear_local() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_ != nullptr) {
    delete _impl_.local_;
  }
  _impl_.local_ = nullptr;
}
inline const ::config::Local& Bootstrap::_internal_local() const {
  const ::config::Local* p = _impl_.local_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Local&>(
      ::config::_Local_default_instance_);
}
inline const ::config::Local& Bootstrap::local() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.local)
  return _internal_local();
}
inline void Bootstrap::unsafe_arena_set_allocated_local(
    ::config::Local* local) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_);
  }
  _impl_.local_ = local;
  if (local) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.local)
}
inline ::config::Local* Bootstrap::release_local() {
  
  ::config::Local* temp = _impl_.local_;
  _impl_.local_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Local* Bootstrap::unsafe_arena_release_local() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.local)
  
  ::config::Local* temp = _impl_.local_;
  _impl_.local_ = nullptr;
  return temp;
}
inline ::config::Local* Bootstrap::_internal_mutable_local() {
  
  if (_impl_.local_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Local>(GetArenaForAllocation());
    _impl_.local_ = p;
  }
  return _impl_.local_;
}
inline ::config::Local* Bootstrap::mutable_local() {
  ::config::Local* _msg = _internal_mutable_local();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.local)
  return _msg;
}
inline void Bootstrap::set_allocated_local(::config::Local* local) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_;
  }
  if (local) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local);
    if (message_arena != submessage_arena) {
      local = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_ = local;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.local)
}

// .config.Serial serial = 3 [json_name = "serial"];
inline bool Bootstrap::_internal_has_serial() const {
  return this != internal_default_instance() && _impl_.serial_ != nullptr;
}
inline bool Bootstrap::has_serial() const {
  return _internal_has_serial();
}
inline void Bootstrap::clear_serial() {
  if (GetArenaForAllocation() == nullptr && _impl_.serial_ != nullptr) {
    delete _impl_.serial_;
  }
  _impl_.serial_ = nullptr;
}
inline const ::config::Serial& Bootstrap::_internal_serial() const {
  const ::config::Serial* p = _impl_.serial_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Serial&>(
      ::config::_Serial_default_instance_);
}
inline const ::config::Serial& Bootstrap::serial() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.serial)
  return _internal_serial();
}
inline void Bootstrap::unsafe_arena_set_allocated_serial(
    ::config::Serial* serial) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serial_);
  }
  _impl_.serial_ = serial;
  if (serial) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Bootstrap.serial)
}
inline ::config::Serial* Bootstrap::release_serial() {
  
  ::config::Serial* temp = _impl_.serial_;
  _impl_.serial_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Serial* Bootstrap::unsafe_arena_release_serial() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.serial)
  
  ::config::Serial* temp = _impl_.serial_;
  _impl_.serial_ = nullptr;
  return temp;
}
inline ::config::Serial* Bootstrap::_internal_mutable_serial() {
  
  if (_impl_.serial_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Serial>(GetArenaForAllocation());
    _impl_.serial_ = p;
  }
  return _impl_.serial_;
}
inline ::config::Serial* Bootstrap::mutable_serial() {
  ::config::Serial* _msg = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.serial)
  return _msg;
}
inline void Bootstrap::set_allocated_serial(::config::Serial* serial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.serial_;
  }
  if (serial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serial);
    if (message_arena != submessage_arena) {
      serial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serial, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.serial_ = serial;
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.serial)
}

// string uuid = 4 [json_name = "uuid"];
inline void Bootstrap::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& Bootstrap::uuid() const {
  // @@protoc_insertion_point(field_get:config.Bootstrap.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Bootstrap::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Bootstrap.uuid)
}
inline std::string* Bootstrap::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:config.Bootstrap.uuid)
  return _s;
}
inline const std::string& Bootstrap::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void Bootstrap::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* Bootstrap::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* Bootstrap::release_uuid() {
  // @@protoc_insertion_point(field_release:config.Bootstrap.uuid)
  return _impl_.uuid_.Release();
}
inline void Bootstrap::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Bootstrap.uuid)
}

// -------------------------------------------------------------------

// Server_GRPC

// string network = 1 [json_name = "network"];
inline void Server_GRPC::clear_network() {
  _impl_.network_.ClearToEmpty();
}
inline const std::string& Server_GRPC::network() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_network(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.network)
}
inline std::string* Server_GRPC::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.network)
  return _s;
}
inline const std::string& Server_GRPC::_internal_network() const {
  return _impl_.network_.Get();
}
inline void Server_GRPC::_internal_set_network(const std::string& value) {
  
  _impl_.network_.Set(value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_network() {
  
  return _impl_.network_.Mutable(GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_network() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.network)
  return _impl_.network_.Release();
}
inline void Server_GRPC::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  _impl_.network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_.IsDefault()) {
    _impl_.network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.network)
}

// string addr = 2 [json_name = "addr"];
inline void Server_GRPC::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Server_GRPC::addr() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Server_GRPC::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Server.GRPC.addr)
}
inline std::string* Server_GRPC::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.addr)
  return _s;
}
inline const std::string& Server_GRPC::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void Server_GRPC::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Server_GRPC::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* Server_GRPC::release_addr() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.addr)
  return _impl_.addr_.Release();
}
inline void Server_GRPC::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3 [json_name = "timeout"];
inline bool Server_GRPC::_internal_has_timeout() const {
  return this != internal_default_instance() && _impl_.timeout_ != nullptr;
}
inline bool Server_GRPC::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Server_GRPC::timeout() const {
  // @@protoc_insertion_point(field_get:config.Server.GRPC.timeout)
  return _internal_timeout();
}
inline void Server_GRPC::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.GRPC.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:config.Server.GRPC.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::_internal_mutable_timeout() {
  
  if (_impl_.timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.timeout_ = p;
  }
  return _impl_.timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Server_GRPC::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:config.Server.GRPC.timeout)
  return _msg;
}
inline void Server_GRPC::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:config.Server.GRPC.timeout)
}

// -------------------------------------------------------------------

// Server

// .config.Server.GRPC grpc = 1 [json_name = "grpc"];
inline bool Server::_internal_has_grpc() const {
  return this != internal_default_instance() && _impl_.grpc_ != nullptr;
}
inline bool Server::has_grpc() const {
  return _internal_has_grpc();
}
inline void Server::clear_grpc() {
  if (GetArenaForAllocation() == nullptr && _impl_.grpc_ != nullptr) {
    delete _impl_.grpc_;
  }
  _impl_.grpc_ = nullptr;
}
inline const ::config::Server_GRPC& Server::_internal_grpc() const {
  const ::config::Server_GRPC* p = _impl_.grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Server_GRPC&>(
      ::config::_Server_GRPC_default_instance_);
}
inline const ::config::Server_GRPC& Server::grpc() const {
  // @@protoc_insertion_point(field_get:config.Server.grpc)
  return _internal_grpc();
}
inline void Server::unsafe_arena_set_allocated_grpc(
    ::config::Server_GRPC* grpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grpc_);
  }
  _impl_.grpc_ = grpc;
  if (grpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Server.grpc)
}
inline ::config::Server_GRPC* Server::release_grpc() {
  
  ::config::Server_GRPC* temp = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Server_GRPC* Server::unsafe_arena_release_grpc() {
  // @@protoc_insertion_point(field_release:config.Server.grpc)
  
  ::config::Server_GRPC* temp = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
  return temp;
}
inline ::config::Server_GRPC* Server::_internal_mutable_grpc() {
  
  if (_impl_.grpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Server_GRPC>(GetArenaForAllocation());
    _impl_.grpc_ = p;
  }
  return _impl_.grpc_;
}
inline ::config::Server_GRPC* Server::mutable_grpc() {
  ::config::Server_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:config.Server.grpc)
  return _msg;
}
inline void Server::set_allocated_grpc(::config::Server_GRPC* grpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grpc_;
  }
  if (grpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grpc);
    if (message_arena != submessage_arena) {
      grpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grpc_ = grpc;
  // @@protoc_insertion_point(field_set_allocated:config.Server.grpc)
}

// -------------------------------------------------------------------

// Local_GRPC

// string network = 1 [json_name = "network"];
inline void Local_GRPC::clear_network() {
  _impl_.network_.ClearToEmpty();
}
inline const std::string& Local_GRPC::network() const {
  // @@protoc_insertion_point(field_get:config.Local.GRPC.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Local_GRPC::set_network(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Local.GRPC.network)
}
inline std::string* Local_GRPC::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:config.Local.GRPC.network)
  return _s;
}
inline const std::string& Local_GRPC::_internal_network() const {
  return _impl_.network_.Get();
}
inline void Local_GRPC::_internal_set_network(const std::string& value) {
  
  _impl_.network_.Set(value, GetArenaForAllocation());
}
inline std::string* Local_GRPC::_internal_mutable_network() {
  
  return _impl_.network_.Mutable(GetArenaForAllocation());
}
inline std::string* Local_GRPC::release_network() {
  // @@protoc_insertion_point(field_release:config.Local.GRPC.network)
  return _impl_.network_.Release();
}
inline void Local_GRPC::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  _impl_.network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_.IsDefault()) {
    _impl_.network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Local.GRPC.network)
}

// string addr = 2 [json_name = "addr"];
inline void Local_GRPC::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Local_GRPC::addr() const {
  // @@protoc_insertion_point(field_get:config.Local.GRPC.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Local_GRPC::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Local.GRPC.addr)
}
inline std::string* Local_GRPC::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:config.Local.GRPC.addr)
  return _s;
}
inline const std::string& Local_GRPC::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void Local_GRPC::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* Local_GRPC::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* Local_GRPC::release_addr() {
  // @@protoc_insertion_point(field_release:config.Local.GRPC.addr)
  return _impl_.addr_.Release();
}
inline void Local_GRPC::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Local.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3 [json_name = "timeout"];
inline bool Local_GRPC::_internal_has_timeout() const {
  return this != internal_default_instance() && _impl_.timeout_ != nullptr;
}
inline bool Local_GRPC::has_timeout() const {
  return _internal_has_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Local_GRPC::_internal_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& Local_GRPC::timeout() const {
  // @@protoc_insertion_point(field_get:config.Local.GRPC.timeout)
  return _internal_timeout();
}
inline void Local_GRPC::unsafe_arena_set_allocated_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Local.GRPC.timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Local_GRPC::release_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Local_GRPC::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:config.Local.GRPC.timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Local_GRPC::_internal_mutable_timeout() {
  
  if (_impl_.timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.timeout_ = p;
  }
  return _impl_.timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* Local_GRPC::mutable_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:config.Local.GRPC.timeout)
  return _msg;
}
inline void Local_GRPC::set_allocated_timeout(::PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout));
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:config.Local.GRPC.timeout)
}

// -------------------------------------------------------------------

// Local

// .config.Local.GRPC grpc = 1 [json_name = "grpc"];
inline bool Local::_internal_has_grpc() const {
  return this != internal_default_instance() && _impl_.grpc_ != nullptr;
}
inline bool Local::has_grpc() const {
  return _internal_has_grpc();
}
inline void Local::clear_grpc() {
  if (GetArenaForAllocation() == nullptr && _impl_.grpc_ != nullptr) {
    delete _impl_.grpc_;
  }
  _impl_.grpc_ = nullptr;
}
inline const ::config::Local_GRPC& Local::_internal_grpc() const {
  const ::config::Local_GRPC* p = _impl_.grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::config::Local_GRPC&>(
      ::config::_Local_GRPC_default_instance_);
}
inline const ::config::Local_GRPC& Local::grpc() const {
  // @@protoc_insertion_point(field_get:config.Local.grpc)
  return _internal_grpc();
}
inline void Local::unsafe_arena_set_allocated_grpc(
    ::config::Local_GRPC* grpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grpc_);
  }
  _impl_.grpc_ = grpc;
  if (grpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:config.Local.grpc)
}
inline ::config::Local_GRPC* Local::release_grpc() {
  
  ::config::Local_GRPC* temp = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::config::Local_GRPC* Local::unsafe_arena_release_grpc() {
  // @@protoc_insertion_point(field_release:config.Local.grpc)
  
  ::config::Local_GRPC* temp = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
  return temp;
}
inline ::config::Local_GRPC* Local::_internal_mutable_grpc() {
  
  if (_impl_.grpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::config::Local_GRPC>(GetArenaForAllocation());
    _impl_.grpc_ = p;
  }
  return _impl_.grpc_;
}
inline ::config::Local_GRPC* Local::mutable_grpc() {
  ::config::Local_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:config.Local.grpc)
  return _msg;
}
inline void Local::set_allocated_grpc(::config::Local_GRPC* grpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grpc_;
  }
  if (grpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grpc);
    if (message_arena != submessage_arena) {
      grpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grpc_ = grpc;
  // @@protoc_insertion_point(field_set_allocated:config.Local.grpc)
}

// -------------------------------------------------------------------

// Serial

// string serial_port = 1 [json_name = "serialPort"];
inline void Serial::clear_serial_port() {
  _impl_.serial_port_.ClearToEmpty();
}
inline const std::string& Serial::serial_port() const {
  // @@protoc_insertion_point(field_get:config.Serial.serial_port)
  return _internal_serial_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Serial::set_serial_port(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_port_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:config.Serial.serial_port)
}
inline std::string* Serial::mutable_serial_port() {
  std::string* _s = _internal_mutable_serial_port();
  // @@protoc_insertion_point(field_mutable:config.Serial.serial_port)
  return _s;
}
inline const std::string& Serial::_internal_serial_port() const {
  return _impl_.serial_port_.Get();
}
inline void Serial::_internal_set_serial_port(const std::string& value) {
  
  _impl_.serial_port_.Set(value, GetArenaForAllocation());
}
inline std::string* Serial::_internal_mutable_serial_port() {
  
  return _impl_.serial_port_.Mutable(GetArenaForAllocation());
}
inline std::string* Serial::release_serial_port() {
  // @@protoc_insertion_point(field_release:config.Serial.serial_port)
  return _impl_.serial_port_.Release();
}
inline void Serial::set_allocated_serial_port(std::string* serial_port) {
  if (serial_port != nullptr) {
    
  } else {
    
  }
  _impl_.serial_port_.SetAllocated(serial_port, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_port_.IsDefault()) {
    _impl_.serial_port_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:config.Serial.serial_port)
}

// int32 baud_rate = 2 [json_name = "baudRate"];
inline void Serial::clear_baud_rate() {
  _impl_.baud_rate_ = 0;
}
inline int32_t Serial::_internal_baud_rate() const {
  return _impl_.baud_rate_;
}
inline int32_t Serial::baud_rate() const {
  // @@protoc_insertion_point(field_get:config.Serial.baud_rate)
  return _internal_baud_rate();
}
inline void Serial::_internal_set_baud_rate(int32_t value) {
  
  _impl_.baud_rate_ = value;
}
inline void Serial::set_baud_rate(int32_t value) {
  _internal_set_baud_rate(value);
  // @@protoc_insertion_point(field_set:config.Serial.baud_rate)
}

// int32 data_bits = 3 [json_name = "dataBits"];
inline void Serial::clear_data_bits() {
  _impl_.data_bits_ = 0;
}
inline int32_t Serial::_internal_data_bits() const {
  return _impl_.data_bits_;
}
inline int32_t Serial::data_bits() const {
  // @@protoc_insertion_point(field_get:config.Serial.data_bits)
  return _internal_data_bits();
}
inline void Serial::_internal_set_data_bits(int32_t value) {
  
  _impl_.data_bits_ = value;
}
inline void Serial::set_data_bits(int32_t value) {
  _internal_set_data_bits(value);
  // @@protoc_insertion_point(field_set:config.Serial.data_bits)
}

// int32 stop_bits = 4 [json_name = "stopBits"];
inline void Serial::clear_stop_bits() {
  _impl_.stop_bits_ = 0;
}
inline int32_t Serial::_internal_stop_bits() const {
  return _impl_.stop_bits_;
}
inline int32_t Serial::stop_bits() const {
  // @@protoc_insertion_point(field_get:config.Serial.stop_bits)
  return _internal_stop_bits();
}
inline void Serial::_internal_set_stop_bits(int32_t value) {
  
  _impl_.stop_bits_ = value;
}
inline void Serial::set_stop_bits(int32_t value) {
  _internal_set_stop_bits(value);
  // @@protoc_insertion_point(field_set:config.Serial.stop_bits)
}

// int32 parity = 5 [json_name = "parity"];
inline void Serial::clear_parity() {
  _impl_.parity_ = 0;
}
inline int32_t Serial::_internal_parity() const {
  return _impl_.parity_;
}
inline int32_t Serial::parity() const {
  // @@protoc_insertion_point(field_get:config.Serial.parity)
  return _internal_parity();
}
inline void Serial::_internal_set_parity(int32_t value) {
  
  _impl_.parity_ = value;
}
inline void Serial::set_parity(int32_t value) {
  _internal_set_parity(value);
  // @@protoc_insertion_point(field_set:config.Serial.parity)
}

// bool flow_control = 6 [json_name = "flowControl"];
inline void Serial::clear_flow_control() {
  _impl_.flow_control_ = false;
}
inline bool Serial::_internal_flow_control() const {
  return _impl_.flow_control_;
}
inline bool Serial::flow_control() const {
  // @@protoc_insertion_point(field_get:config.Serial.flow_control)
  return _internal_flow_control();
}
inline void Serial::_internal_set_flow_control(bool value) {
  
  _impl_.flow_control_ = value;
}
inline void Serial::set_flow_control(bool value) {
  _internal_set_flow_control(value);
  // @@protoc_insertion_point(field_set:config.Serial.flow_control)
}

// bool clocal = 7 [json_name = "clocal"];
inline void Serial::clear_clocal() {
  _impl_.clocal_ = false;
}
inline bool Serial::_internal_clocal() const {
  return _impl_.clocal_;
}
inline bool Serial::clocal() const {
  // @@protoc_insertion_point(field_get:config.Serial.clocal)
  return _internal_clocal();
}
inline void Serial::_internal_set_clocal(bool value) {
  
  _impl_.clocal_ = value;
}
inline void Serial::set_clocal(bool value) {
  _internal_set_clocal(value);
  // @@protoc_insertion_point(field_set:config.Serial.clocal)
}

// -------------------------------------------------------------------

// PlatInfo_InternalArray

// int64 index = 1 [json_name = "index"];
inline void PlatInfo_InternalArray::clear_index() {
  _impl_.index_ = int64_t{0};
}
inline int64_t PlatInfo_InternalArray::_internal_index() const {
  return _impl_.index_;
}
inline int64_t PlatInfo_InternalArray::index() const {
  // @@protoc_insertion_point(field_get:config.PlatInfo.InternalArray.index)
  return _internal_index();
}
inline void PlatInfo_InternalArray::_internal_set_index(int64_t value) {
  
  _impl_.index_ = value;
}
inline void PlatInfo_InternalArray::set_index(int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:config.PlatInfo.InternalArray.index)
}

// repeated double items = 2 [json_name = "items"];
inline int PlatInfo_InternalArray::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int PlatInfo_InternalArray::items_size() const {
  return _internal_items_size();
}
inline void PlatInfo_InternalArray::clear_items() {
  _impl_.items_.Clear();
}
inline double PlatInfo_InternalArray::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline double PlatInfo_InternalArray::items(int index) const {
  // @@protoc_insertion_point(field_get:config.PlatInfo.InternalArray.items)
  return _internal_items(index);
}
inline void PlatInfo_InternalArray::set_items(int index, double value) {
  _impl_.items_.Set(index, value);
  // @@protoc_insertion_point(field_set:config.PlatInfo.InternalArray.items)
}
inline void PlatInfo_InternalArray::_internal_add_items(double value) {
  _impl_.items_.Add(value);
}
inline void PlatInfo_InternalArray::add_items(double value) {
  _internal_add_items(value);
  // @@protoc_insertion_point(field_add:config.PlatInfo.InternalArray.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PlatInfo_InternalArray::_internal_items() const {
  return _impl_.items_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PlatInfo_InternalArray::items() const {
  // @@protoc_insertion_point(field_list:config.PlatInfo.InternalArray.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PlatInfo_InternalArray::_internal_mutable_items() {
  return &_impl_.items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PlatInfo_InternalArray::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:config.PlatInfo.InternalArray.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// PlatInfo

// int32 ltmp = 1 [json_name = "ltmp"];
inline void PlatInfo::clear_ltmp() {
  _impl_.ltmp_ = 0;
}
inline int32_t PlatInfo::_internal_ltmp() const {
  return _impl_.ltmp_;
}
inline int32_t PlatInfo::ltmp() const {
  // @@protoc_insertion_point(field_get:config.PlatInfo.ltmp)
  return _internal_ltmp();
}
inline void PlatInfo::_internal_set_ltmp(int32_t value) {
  
  _impl_.ltmp_ = value;
}
inline void PlatInfo::set_ltmp(int32_t value) {
  _internal_set_ltmp(value);
  // @@protoc_insertion_point(field_set:config.PlatInfo.ltmp)
}

// repeated .config.PlatInfo.InternalArray ancher = 2 [json_name = "ancher"];
inline int PlatInfo::_internal_ancher_size() const {
  return _impl_.ancher_.size();
}
inline int PlatInfo::ancher_size() const {
  return _internal_ancher_size();
}
inline void PlatInfo::clear_ancher() {
  _impl_.ancher_.Clear();
}
inline ::config::PlatInfo_InternalArray* PlatInfo::mutable_ancher(int index) {
  // @@protoc_insertion_point(field_mutable:config.PlatInfo.ancher)
  return _impl_.ancher_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >*
PlatInfo::mutable_ancher() {
  // @@protoc_insertion_point(field_mutable_list:config.PlatInfo.ancher)
  return &_impl_.ancher_;
}
inline const ::config::PlatInfo_InternalArray& PlatInfo::_internal_ancher(int index) const {
  return _impl_.ancher_.Get(index);
}
inline const ::config::PlatInfo_InternalArray& PlatInfo::ancher(int index) const {
  // @@protoc_insertion_point(field_get:config.PlatInfo.ancher)
  return _internal_ancher(index);
}
inline ::config::PlatInfo_InternalArray* PlatInfo::_internal_add_ancher() {
  return _impl_.ancher_.Add();
}
inline ::config::PlatInfo_InternalArray* PlatInfo::add_ancher() {
  ::config::PlatInfo_InternalArray* _add = _internal_add_ancher();
  // @@protoc_insertion_point(field_add:config.PlatInfo.ancher)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >&
PlatInfo::ancher() const {
  // @@protoc_insertion_point(field_list:config.PlatInfo.ancher)
  return _impl_.ancher_;
}

// repeated .config.PlatInfo.InternalArray plate = 3 [json_name = "plate"];
inline int PlatInfo::_internal_plate_size() const {
  return _impl_.plate_.size();
}
inline int PlatInfo::plate_size() const {
  return _internal_plate_size();
}
inline void PlatInfo::clear_plate() {
  _impl_.plate_.Clear();
}
inline ::config::PlatInfo_InternalArray* PlatInfo::mutable_plate(int index) {
  // @@protoc_insertion_point(field_mutable:config.PlatInfo.plate)
  return _impl_.plate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >*
PlatInfo::mutable_plate() {
  // @@protoc_insertion_point(field_mutable_list:config.PlatInfo.plate)
  return &_impl_.plate_;
}
inline const ::config::PlatInfo_InternalArray& PlatInfo::_internal_plate(int index) const {
  return _impl_.plate_.Get(index);
}
inline const ::config::PlatInfo_InternalArray& PlatInfo::plate(int index) const {
  // @@protoc_insertion_point(field_get:config.PlatInfo.plate)
  return _internal_plate(index);
}
inline ::config::PlatInfo_InternalArray* PlatInfo::_internal_add_plate() {
  return _impl_.plate_.Add();
}
inline ::config::PlatInfo_InternalArray* PlatInfo::add_plate() {
  ::config::PlatInfo_InternalArray* _add = _internal_add_plate();
  // @@protoc_insertion_point(field_add:config.PlatInfo.plate)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::config::PlatInfo_InternalArray >&
PlatInfo::plate() const {
  // @@protoc_insertion_point(field_list:config.PlatInfo.plate)
  return _impl_.plate_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_conf_2eproto
